<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>IQ100 智力問答遊戲</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f2f5;
        }

        #gameContainer {
            text-align: center;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .state {
            display: none;
        }

        .active {
            display: block;
        }

        .start-button, .option-button, .next-button {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
            background-color: #4CAF50;
            color: white;
        }

        .start-button:hover, .option-button:hover, .next-button:hover {
            transform: scale(1.05);
        }

        .option-button {
            width: 80%;
            text-align: left;
            background-color: #f8f9fa;
            color: #333;
            border: 2px solid #ddd;
        }

        .option-button.correct {
            background-color: #4CAF50;
            color: white;
        }

        .option-button.wrong {
            background-color: #f44336;
            color: white;
        }

        .score {
            font-size: 24px;
            margin: 20px 0;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .shake {
            animation: shake 0.5s;
        }

        #stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .thinking {
            font-size: 20px;
            color: #666;
            margin: 20px 0;
        }

        .thinking::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- 開始畫面 -->
        <div id="startState" class="state active">
            <h1>🧠 IQ100 智力問答遊戲 🎮</h1>
            <button class="start-button" onclick="開始遊戲()">開始遊戲 🎯</button>
        </div>

        <!-- AI生成題目狀態 -->
        <div id="generatingState" class="state">
            <div class="thinking">AI 正在思考問題中 🤔</div>
        </div>

        <!-- 答題狀態 -->
        <div id="questionState" class="state">
            <div class="score">得分: <span id="scoreDisplay">0</span></div>
            <div id="questionText"></div>
            <div id="options"></div>
        </div>

        <!-- 遊戲結束狀態 -->
        <div id="endState" class="state">
            <h2>遊戲結束！</h2>
            <div class="score">最終得分: <span id="finalScore">0</span></div>
            <button class="start-button" onclick="重置遊戲()">重新開始 🔄</button>
        </div>
    </div>

    <canvas id="stars"></canvas>

    <script>
        const API金鑰 = 'xai-33XUsyMtsKwFsYNNKCbsOCoMsp4rnSjERK3MxLLAaR3kjO9eEaIwH6SXF7KIjw91OswhE1vgweXZKpE9';
        let 目前分數 = 0;
        let 題目計數 = 0;
        let 之前的題目 = [];
        let 目前題目 = null;

        /**
         * 切換遊戲狀態顯示
         * @param {string} 狀態ID - 要顯示的狀態區塊ID
         */
        function 顯示狀態(狀態ID) {
            // 隱藏所有狀態
            document.querySelectorAll('.state').forEach(狀態 => 狀態.classList.remove('active'));
            // 顯示指定狀態
            document.getElementById(狀態ID).classList.add('active');
        }

        /**
         * 開始新遊戲
         */
        function 開始遊戲() {
            目前分數 = 0;
            題目計數 = 0;
            之前的題目 = [];
            產生題目();
        }

        /**
         * 重置遊戲狀態
         */
        function 重置遊戲() {
            顯示狀態('startState');
        }

        /**
         * 向 AI 請求並產生新題目
         */
        async function 產生題目() {
            顯示狀態('generatingState');
            
            const 提示文字 = `請生成一個小學生的百科知識問答題目，格式如下：
            {
                "question": "問題內容",
                "options": {
                    "A": "選項A",
                    "B": "選項B",
                    "C": "選項C",
                    "D": "選項D"
                },
                "answer": "正確答案字母"
            }
            請只返回純JSON格式，不要加入其他文字。
            這是之前出過的題目請不要重複：${JSON.stringify(之前的題目)}`;

            try {
                // 發送 API 請求
                const 回應 = await fetch('https://api.x.ai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API金鑰}`
                    },
                    body: JSON.stringify({
                        model: "grok-beta",
                        messages: [{
                            role: "user",
                            content: 提示文字
                        }]
                    })
                });

                const 資料 = await 回應.json();
                console.log('AI 回應:', 資料);

                // 解析 JSON 回應
                const 內容 = 資料.choices[0].message.content;
                const JSON符合 = 內容.match(/\{[\s\S]*\}/);
                
                if (JSON符合) {
                    目前題目 = JSON.parse(JSON符合[0]);
                    之前的題目.push(目前題目);
                    顯示題目(目前題目);
                } else {
                    console.error('無法解析JSON');
                    document.getElementById('generatingState').innerHTML += `
                        <div>生成失敗，請重試</div>
                        <button class="next-button" onclick="產生題目()">再生成</button>
                    `;
                }
            } catch (錯誤) {
                console.error('錯誤:', 錯誤);
                document.getElementById('generatingState').innerHTML += `
                    <div>發生錯誤：${錯誤.message}</div>
                    <button class="next-button" onclick="產生題目()">再生成</button>
                `;
            }
        }

        /**
         * 顯示題目到畫面上
         * @param {Object} 題目 - 題目物件
         */
        function 顯示題目(題目) {
            顯示狀態('questionState');
            document.getElementById('scoreDisplay').textContent = 目前分數;
            document.getElementById('questionText').innerHTML = `<h2>📝 ${題目.question}</h2>`;
            
            const 選項容器 = document.getElementById('options');
            選項容器.innerHTML = '';
            
            // 建立選項按鈕
            Object.entries(題目.options).forEach(([選項, 內容]) => {
                const 按鈕 = document.createElement('button');
                按鈕.className = 'option-button';
                按鈕.innerHTML = `${選項}. ${內容}`;
                按鈕.onclick = () => 檢查答案(選項);
                選項容器.appendChild(按鈕);
            });
        }

        /**
         * 檢查答案是否正確並處理結果
         * @param {string} 選擇的答案 - 使用者選擇的選項
         */
        function 檢查答案(選擇的答案) {
            const 是否正確 = 選擇的答案 === 目前題目.answer;
            const 按鈕們 = document.querySelectorAll('.option-button');
            
            // 停用所有按鈕並標示正確/錯誤答案
            按鈕們.forEach(按鈕 => {
                按鈕.disabled = true;
                const 按鈕答案 = 按鈕.innerHTML[0];
                if (按鈕答案 === 目前題目.answer) {
                    按鈕.classList.add('correct');
                } else if (按鈕答案 === 選擇的答案 && !是否正確) {
                    按鈕.classList.add('wrong');
                }
            });

            // 處理答對/答錯效果
            if (是否正確) {
                目前分數 += 10;
                創建星星爆炸();
            } else {
                document.getElementById('questionState').classList.add('shake');
                setTimeout(() => {
                    document.getElementById('questionState').classList.remove('shake');
                }, 500);
            }

            題目計數++;
            setTimeout(() => {
                if (題目計數 >= 10) {
                    結束遊戲();
                } else {
                    產生題目();
                }
            }, 1500);
        }

/**
 * 創建答對時的星星爆炸動畫效果
 * 包含更大的星星和重力效果
 */
function 創建星星爆炸() {
    const 畫布 = document.getElementById('stars');
    const 繪圖環境 = 畫布.getContext('2d');
    畫布.width = window.innerWidth;
    畫布.height = window.innerHeight;

    // 重力相關常數
    const 重力 = 0.5;  // 重力加速度
    const 反彈係數 = 0.6;  // 碰撞地面後的反彈力度

    const 星星們 = [];
    // 產生30顆較大的星星
    for (let i = 0; i < 30; i++) {
        星星們.push({
            x: window.innerWidth / 2,
            y: window.innerHeight / 2,
            大小: Math.random() * 8 + 5,  // 增加星星大小範圍
            速度X: (Math.random() - 0.5) * 15,  // 水平速度
            速度Y: -Math.random() * 15,  // 向上的初始速度
            透明度: 1,
            顏色: `hsl(${Math.random() * 60 + 40}, 100%, 50%)`  // 金黃色系的隨機色彩
        });
    }

    function 動畫() {
        // 使用半透明背景製造拖尾效果
        繪圖環境.fillStyle = 'rgba(0, 0, 0, 0.1)';
        繪圖環境.fillRect(0, 0, 畫布.width, 畫布.height);
        
        let 仍然可見 = false;

        星星們.forEach(星星 => {
            // 更新位置
            星星.x += 星星.速度X;
            星星.y += 星星.速度Y;
            
            // 加入重力效果
            星星.速度Y += 重力;

            // 地面碰撞檢測
            if (星星.y + 星星.大小 > 畫布.height) {
                星星.y = 畫布.height - 星星.大小;
                星星.速度Y = -星星.速度Y * 反彈係數;
                // 減少水平速度（模擬摩擦）
                星星.速度X *= 0.8;
            }

            // 牆壁碰撞檢測
            if (星星.x + 星星.大小 > 畫布.width || 星星.x - 星星.大小 < 0) {
                星星.速度X *= -0.8;
            }

            // 逐漸降低透明度
            星星.透明度 -= 0.005;

            // 繪製星星
            if (星星.透明度 > 0) {
                仍然可見 = true;
                繪圖環境.beginPath();
                繪圖環境.fillStyle = `hsla(${星星.顏色}, ${星星.透明度})`;
                
                // 繪製發光效果
                const 漸層 = 繪圖環境.createRadialGradient(
                    星星.x, 星星.y, 0,
                    星星.x, 星星.y, 星星.大小
                );
                漸層.addColorStop(0, `rgba(255, 255, 200, ${星星.透明度})`);
                漸層.addColorStop(0.4, `rgba(255, 200, 0, ${星星.透明度 * 0.8})`);
                漸層.addColorStop(1, `rgba(255, 100, 0, 0)`);
                
                繪圖環境.fillStyle = 漸層;
                繪圖環境.arc(星星.x, 星星.y, 星星.大小, 0, Math.PI * 2);
                繪圖環境.fill();

                // 添加星星光芒效果
                繪圖環境.save();
                繪圖環境.translate(星星.x, 星星.y);
                繪圖環境.rotate(Math.PI / 4);
                
                for (let i = 0; i < 4; i++) {
                    繪圖環境.rotate(Math.PI / 2);
                    繪圖環境.beginPath();
                    繪圖環境.moveTo(0, -星星.大小 * 1.5);
                    繪圖環境.lineTo(0, 星星.大小 * 1.5);
                    繪圖環境.strokeStyle = `rgba(255, 255, 200, ${星星.透明度 * 0.3})`;
                    繪圖環境.lineWidth = 2;
                    繪圖環境.stroke();
                }
                
                繪圖環境.restore();
            }
        });

        // 如果還有可見的星星，繼續動畫
        if (仍然可見) {
            requestAnimationFrame(動畫);
        } else {
            // 清除畫布
            繪圖環境.clearRect(0, 0, 畫布.width, 畫布.height);
        }
    }

    動畫();
}



        function 結束遊戲() {
            document.getElementById('finalScore').textContent = 目前分數;
            顯示狀態('endState');
        }
    </script>
</body>
</html>
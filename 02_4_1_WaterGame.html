<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            overflow: hidden;
        }
        #gameCanvas {
            width: 100%;
            height: 100vh;
        }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            cursor: pointer;
            display: none;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            display: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="message"></div>
    <button id="startButton">é–‹å§‹éŠæˆ²</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const GameState = {
            START: 'start',
            PLAYING: 'playing',
            END: 'end'
        };

        let currentState = GameState.START;
        let engine, render, world;
        let blueBox, redBox;
        let blueHealth = 1000;
        let redHealth = 100;
        let isDrawing = false;
        let points = [];
        let ballSpawnInterval;

        // å°‡ emoji è½‰æ›ç‚ºåœ–ç‰‡ URL
        function emojiToURL(emoji, size = 80) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.font = `${size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, size/2, size/2);
            return canvas.toDataURL();
        }

        // åˆå§‹åŒ–ç‰©ç†å¼•æ“
        function init() {
            engine = Matter.Engine.create({
                gravity: { x: 0, y: 1 }
            });
            world = engine.world;

            render = Matter.Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: '#1a1a1a'
                }
            });

            Matter.Render.run(render);
            Matter.Runner.run(engine);
        }

        // å‰µå»ºæ–¹å¡Š
        function createBoxes() {
            const blueBoxTexture = emojiToURL('ğŸ°');
            const redBoxTexture = emojiToURL('ğŸ‘¾');

            blueBox = Matter.Bodies.rectangle(100, 100, 80, 80, {
                isStatic: true,
                render: {
                    sprite: {
                        texture: blueBoxTexture,
                        xScale: 1,
                        yScale: 1
                    }
                }
            });

            redBox = Matter.Bodies.rectangle(window.innerWidth - 100, window.innerHeight - 100, 80, 80, {
                isStatic: true,
                render: {
                    sprite: {
                        texture: redBoxTexture,
                        xScale: 1,
                        yScale: 1
                    }
                }
            });

            Matter.World.add(world, [blueBox, redBox]);
        }

        // ç”Ÿæˆå°çƒ
        function spawnBall() {
            if (blueHealth <= 0) return;
            
            const ballTexture = emojiToURL('ğŸ’§', 20);
            const ball = Matter.Bodies.circle(
                blueBox.position.x,
                blueBox.position.y,
                10,
                {
                    render: {
                        sprite: {
                            texture: ballTexture,
                            xScale: 1,
                            yScale: 1
                        }
                    }
                }
            );

            Matter.Body.setVelocity(ball, {
                x: (Math.random() - 0.5) * 10,
                y: 5
            });

            Matter.World.add(world, ball);
            blueHealth--;

            // ç¢°æ’æª¢æ¸¬
            Matter.Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    if ((pair.bodyA === ball && pair.bodyB === redBox) ||
                        (pair.bodyA === redBox && pair.bodyB === ball)) {
                        Matter.World.remove(world, ball);
                        redHealth--;
                        flashRedBox();
                    }
                });
            });
        }

        // ç´…è‰²æ–¹å¡Šé–ƒçˆ
        function flashRedBox() {
            const originalTexture = redBox.render.sprite.texture;
            redBox.render.sprite.texture = emojiToURL('ğŸ’¥');
            setTimeout(() => {
                redBox.render.sprite.texture = originalTexture;
            }, 100);
        }

        // ç•«ç·š
        function handleDrawing() {
            const canvas = render.canvas;
            let currentLine = null;

            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                points = [];
                points.push({ x: e.clientX, y: e.clientY });
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                points.push({ x: e.clientX, y: e.clientY });
                
                if (points.length >= 2) {
                    const startPoint = points[points.length - 2];
                    const endPoint = points[points.length - 1];
                    
                    const line = Matter.Bodies.rectangle(
                        (startPoint.x + endPoint.x) / 2,
                        (startPoint.y + endPoint.y) / 2,
                        Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)),
                        15,
                        {
                            isStatic: true,
                            angle: Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x),
                            render: {
                                sprite: {
                                    texture: emojiToURL('ğŸŒŸ', 15),
                                    xScale: 1,
                                    yScale: 1
                                }
                            }
                        }
                    );
                    
                    Matter.World.add(world, line);
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });
        }

        // ç‹€æ…‹ç®¡ç†
        function setState(state) {
            currentState = state;
            switch (state) {
                case GameState.START:
                    document.getElementById('startButton').style.display = 'block';
                    document.getElementById('message').style.display = 'none';
                    resetGame();
                    break;
                case GameState.PLAYING:
                    document.getElementById('startButton').style.display = 'none';
                    ballSpawnInterval = setInterval(spawnBall, 100);
                    break;
                case GameState.END:
                    clearInterval(ballSpawnInterval);
                    const message = document.getElementById('message');
                    message.style.display = 'block';
                    if (blueHealth <= 0) {
                        message.innerHTML = 'ä½ è¼¸äº†';
                    } else {
                        message.innerHTML = `ä½ è´äº†<br>åˆ†æ•¸: ${blueHealth}`;
                    }
                    setTimeout(() => setState(GameState.START), 5000);
                    break;
            }
        }

        // é‡ç½®éŠæˆ²
        function resetGame() {
            Matter.World.clear(world);
            blueHealth = 1000;
            redHealth = 100;
            createBoxes();
        }

        // éŠæˆ²å¾ªç’°
        function gameLoop() {
            if (currentState === GameState.PLAYING) {
                // æ›´æ–°ç”Ÿå‘½å€¼é¡¯ç¤º
                const ctx = render.context;
                ctx.font = '20px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // è—è‰²æ–¹å¡Šç”Ÿå‘½å€¼
                ctx.fillText(
                    blueHealth.toString(), 
                    blueBox.position.x, 
                    blueBox.position.y
                );
                
                // ç´…è‰²æ–¹å¡Šç”Ÿå‘½å€¼
                ctx.fillText(
                    redHealth.toString(), 
                    redBox.position.x, 
                    redBox.position.y
                );

                Matter.Body.setPosition(blueBox, { x: 100, y: 100 });
                Matter.Body.setPosition(redBox, { x: window.innerWidth - 100, y: window.innerHeight - 100 });

                // æª¢æŸ¥éŠæˆ²çµæŸæ¢ä»¶
                if (blueHealth <= 0 || redHealth <= 0) {
                    setState(GameState.END);
                }
            }
            requestAnimationFrame(gameLoop);
        }

        // åˆå§‹åŒ–éŠæˆ²
        init();
        handleDrawing();
        document.getElementById('startButton').addEventListener('click', () => setState(GameState.PLAYING));
        setState(GameState.START);
        gameLoop();
    </script>
</body>
</html>